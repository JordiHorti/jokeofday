define("core/fetch",["exports","core/config","./pending"],(function(_exports,_config,_pending){function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}
/**
   * The core/fetch module allows you to make web service requests to the Moodle API.
   *
   * @module     core/fetch
   * @copyright  Andrew Lyons <andrew@nicols.co.uk>
   * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later
   * @example <caption>Perform a single GET request</caption>
   * import Fetch from 'core/fetch';
   *
   * const result = Fetch.performGet('mod_example', 'animals', { params: { type: 'mammal' } });
   *
   * result.then((response) => {
   *    // Do something with the Response object.
   * })
   * .catch((error) => {
   *     // Handle the error
   * });
   */Object.defineProperty(_exports,"__esModule",{value:!0}),_exports.default=void 0,_config=_interopRequireDefault(_config),_pending=_interopRequireDefault(_pending);class RequestWrapper{#request=null;#promise=null;#resolve=null;#reject=null;constructor(request){this.#request=request,this.#promise=new Promise(((resolve,reject)=>{this.#resolve=resolve,this.#reject=reject}))}get request(){return this.#request}get promise(){return this.#promise}handleResponse(response){response.ok?this.#resolve(response):this.#reject(response.statusText)}}class Fetch{static async request(component,action){let{params:params={},body:body=null,method:method="GET"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const pending=new _pending.default(`Requesting ${component}/${action} with ${method}`),requestWrapper=Fetch.#getRequest(Fetch.#normaliseComponent(component),action,{params:params,method:method,body:body}),result=await fetch(requestWrapper.request);return pending.resolve(),requestWrapper.handleResponse(result),requestWrapper.promise}static performGet(component,action){let{params:params={}}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.request(component,action,{params:params,method:"GET"})}static performHead(component,action){let{params:params={}}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.request(component,action,{params:params,method:"HEAD"})}static performPost(component,action){let{body:body}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.request(component,action,{body:body,method:"POST"})}static performPut(component,action){let{body:body}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.request(component,action,{body:body,method:"PUT"})}static performPatch(component,action){let{body:body}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.request(component,action,{body:body,method:"PATCH"})}static performDelete(component,action){let{params:params={},body:body=null}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this.request(component,action,{body:body,params:params,method:"DELETE"})}static#normaliseComponent(component){return component.replace(/^core_/,"")}static#getRequest(component,endpoint,_ref){let{params:params={},body:body=null,method:method="GET"}=_ref;const url=new URL(`${_config.default.apibase}/rest/v2/${component}/${endpoint}`),options={method:method,headers:{Accept:"application/json","Content-Type":"application/json"}};return Object.entries(params).forEach((_ref2=>{let[key,value]=_ref2;url.searchParams.append(key,value)})),body&&(body instanceof FormData?options.body=body:options.body=body instanceof Object?JSON.stringify(body):body),new RequestWrapper(new Request(url,options))}}return _exports.default=Fetch,_exports.default}));

//# sourceMappingURL=fetch.min.js.map