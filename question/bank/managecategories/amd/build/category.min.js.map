{"version":3,"file":"category.min.js","sources":["../src/category.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * The category component.\n *\n * @module     qbank_managecategories/category\n * @class      qbank_managecategories/category\n */\n\nimport {BaseComponent, DragDrop} from 'core/reactive';\nimport {categorymanager} from 'qbank_managecategories/categorymanager';\nimport Templates from 'core/templates';\nimport Modal from \"core/modal\";\nimport {get_string as getString} from \"core/str\";\n\nexport default class extends BaseComponent {\n\n    create(descriptor) {\n        this.name = descriptor.element.id;\n        this.selectors = {\n            CATEGORY_LIST: '.qbank_managecategories-categorylist',\n            CATEGORY_ITEM: '.qbank_managecategories-item[data-categoryid]',\n            CATEGORY_CONTENTS: '.qbank_managecategories-item > .container',\n            EDIT_BUTTON: '[data-action=\"addeditcategory\"]',\n            MOVE_BUTTON: '[role=\"menuitem\"][data-actiontype=\"move\"]',\n            CONTEXT: '.qbank_managecategories-categorylist[data-contextid]',\n            MODAL_CATEGORY_ITEM: '.modal_category_item[data-movingcategoryid]',\n            CONTENT_AREA: '.qbank_managecategories-details',\n            CATEGORY_ID: id => `#category-${id}`,\n            CONTENT_CONTAINER: id => `#category-${id} .qbank_managecategories-childlistcontainer`,\n            CHILD_LIST: id => `ul[data-categoryid=\"${id}\"]`,\n            PREVIOUS_SIBLING: sortorder => `:scope > [data-sortorder=\"${sortorder}\"]`,\n        };\n        this.classes = {\n            NO_BOTTOM_PADDING: 'pb-0',\n            DRAGHANDLE: 'draghandle',\n            DROPTARGET: 'qbank_managecategories-droptarget-before',\n        };\n        this.ids = {\n            CATEGORY: id => `category-${id}`,\n        };\n    }\n\n    stateReady() {\n        this.initDragDrop();\n        this.addEventListener(this.getElement(this.selectors.EDIT_BUTTON), 'click', categorymanager.showEditModal);\n        const moveButton = this.getElement(this.selectors.MOVE_BUTTON);\n        this.addEventListener(moveButton, 'click', this.showMoveModal);\n    }\n\n    destroy() {\n        // The draggable element must be unregistered.\n        this.deInitDragDrop();\n    }\n\n    /**\n     * Remove any existing DragDrop component, and create a new one.\n     */\n    initDragDrop() {\n        this.deInitDragDrop();\n        // If the element is currently draggable, register the getDraggableData method.\n        if (this.element.classList.contains(this.classes.DRAGHANDLE)) {\n            this.getDraggableData = this._getDraggableData;\n        }\n        this.dragdrop = new DragDrop(this);\n    }\n\n    /**\n     * If the DragDrop component is currently registered, unregister it.\n     */\n    deInitDragDrop() {\n        if (this.dragdrop !== undefined) {\n            if (this.getDraggableData !== undefined) {\n                this.dragdrop.setDraggable(false);\n                this.getDraggableData = undefined;\n            }\n            this.dragdrop.unregister();\n            this.dragdrop = undefined;\n        }\n    }\n\n    /**\n     * Static method to create a component instance.\n     *\n     * @param {string} target the DOM main element or its ID\n     * @param {object} selectors optional css selector overrides\n     * @return {Component}\n     */\n    static init(target, selectors) {\n        return new this({\n            element: document.querySelector(target),\n            selectors,\n            reactive: categorymanager,\n        });\n    }\n\n    /**\n     * Return the category ID from the component's element.\n     *\n     * This method is referenced as getDraggableData when the component can be dragged.\n     *\n     * @return {{id: string}}\n     * @private\n     */\n    _getDraggableData() {\n        return {\n            id: this.getElement().dataset.categoryid\n        };\n    }\n\n    validateDropData() {\n        return true;\n    }\n\n    /**\n     * Highlight the top border of the category item.\n     *\n     * @param {Object} dropData\n     */\n    showDropZone(dropData) {\n        if (this.getElement().closest(this.selectors.CATEGORY_ID(dropData.id))) {\n            // Can't drop onto itself or its own child.\n            return false;\n        }\n        this.getElement().classList.add(this.classes.DROPTARGET);\n        return true;\n    }\n\n    /**\n     * Remove highlighting.\n     */\n    hideDropZone() {\n        this.getElement().classList.remove(this.classes.DROPTARGET);\n    }\n\n    /**\n     * Find the new position of the dropped category, and trigger the move.\n     *\n     * @param {Object} dropData The category being moved.\n     * @param {Event} event The drop event.\n     */\n    drop(dropData, event) {\n        const dropTarget = event.target.closest(this.selectors.CATEGORY_ITEM);\n\n        if (!dropTarget) {\n            return;\n        }\n\n        if (dropTarget.closest(this.selectors.CATEGORY_ID(dropData.id))) {\n            // Can't drop onto your own child.\n            return;\n        }\n\n        const source = document.getElementById(this.ids.CATEGORY(dropData.id));\n\n        if (!source) {\n            return;\n        }\n\n        const targetParentId = dropTarget.dataset.parent;\n        const parentList = dropTarget.closest(this.selectors.CATEGORY_LIST);\n        let precedingSibling;\n\n        if (dropTarget === parentList.firstElementChild) {\n            // Dropped at the top of the list.\n            precedingSibling = null;\n        } else {\n            precedingSibling = dropTarget.previousElementSibling;\n        }\n\n        // Insert the category after the target category\n        categorymanager.moveCategory(dropData.id, targetParentId, precedingSibling?.dataset.categoryid);\n    }\n\n    getWatchers() {\n        return [\n            // After any update to this category, move it to the new position.\n            {watch: `categories[${this.element.dataset.categoryid}]:updated`, handler: this.updatePosition},\n            // When the template context is added or updated, re-render the content.\n            {watch: `categories[${this.element.dataset.categoryid}].templatecontext:created`, handler: this.rerender},\n            {watch: `categories[${this.element.dataset.categoryid}].templatecontext:updated`, handler: this.rerender},\n            // When a new category is created, check whether we need to add a child list to this category.\n            {watch: `categories:created`, handler: this.checkChildList},\n        ];\n    }\n\n    /**\n     * Re-render the category content.\n     *\n     * @param {Object} args\n     * @param {Element} args.element\n     * @return {Promise<Array>}\n     */\n    async rerender({element}) {\n        const {html, js} = await Templates.renderForPromise(\n            'qbank_managecategories/category_details',\n            element.templatecontext\n        );\n        return Templates.replaceNodeContents(this.getElement(this.selectors.CONTENT_AREA), html, js);\n    }\n\n    /**\n     * Render and append a new child list.\n     *\n     * @param {Object} context Template context, must include at least categoryid.\n     * @return {Promise<Element>}\n     */\n    async createChildList(context) {\n        const {html, js} = await Templates.renderForPromise(\n            'qbank_managecategories/childlist',\n            context,\n        );\n        const parentContainer = document.querySelector(this.selectors.CONTENT_CONTAINER(context.categoryid));\n        await Templates.appendNodeContents(parentContainer, html, js);\n        const childList = document.querySelector(this.selectors.CHILD_LIST(context.categoryid));\n        childList.closest(this.selectors.CATEGORY_CONTENTS).classList.add(this.classes.NO_BOTTOM_PADDING);\n        return childList;\n    }\n\n    /**\n     * Move a category to its new position.\n     *\n     * A category may change its parent, sortorder and draghandle independently or at the same time. This method will resolve those\n     * changes and move the element to the new position. If the parent doesn't already have a child list, one will be created.\n     *\n     * If the parent has changed, this will also update the state with the new child count of the old and new parents.\n     *\n     * @param {Object} args\n     * @param {Object} args.element\n     * @return {Promise<void>}\n     */\n    async updatePosition({element}) {\n        // Move to a new parent category.\n        let newParent;\n        const originParent = document.querySelector(this.selectors.CHILD_LIST(this.getElement().dataset.parent));\n        if (parseInt(this.getElement().dataset.parent) !== element.parent) {\n            newParent = document.querySelector(this.selectors.CHILD_LIST(element.parent));\n            if (!newParent) {\n                // The target category doesn't have a child list yet. We'd better create one.\n                newParent = await this.createChildList({categoryid: element.parent});\n            }\n            this.getElement().dataset.parent = element.parent;\n        } else {\n            newParent = this.getElement().parentElement;\n        }\n\n        // Move to a new position within the parent.\n        let previousSibling;\n        let nextSibling;\n        if (newParent.firstElementChild && parseInt(element.sortorder) <= parseInt(newParent.firstElementChild.dataset.sortorder)) {\n            // Move to the top of the list.\n            nextSibling = newParent.firstElementChild;\n        } else {\n            // Move later in the list.\n            previousSibling = newParent.querySelector(this.selectors.PREVIOUS_SIBLING(element.sortorder - 1));\n            nextSibling = previousSibling?.nextElementSibling;\n        }\n\n        // Check if this has actually moved, or if it's just having its sortorder updated due to another element moving.\n        const moved = (newParent !== this.getElement().parentElement || nextSibling !== this.getElement());\n\n        if (moved) {\n            if (nextSibling) {\n                // Move to the specified position in the list.\n                newParent.insertBefore(this.getElement(), nextSibling);\n            } else {\n                // Move to the end of the list (may also be the top of the list is empty).\n                newParent.appendChild(this.getElement());\n            }\n        }\n        if (originParent !== newParent) {\n            // Update child count of old and new parent.\n            this.reactive.stateManager.processUpdates([\n                {\n                    name: 'categoryLists',\n                    action: 'put',\n                    fields: {\n                        id: originParent.dataset.categoryid,\n                        childCount: originParent.querySelectorAll(this.selectors.CATEGORY_ITEM).length\n                    }\n                },\n                {\n                    name: 'categoryLists',\n                    action: 'put',\n                    fields: {\n                        id: newParent.dataset.categoryid,\n                        childCount: newParent.querySelectorAll(this.selectors.CATEGORY_ITEM).length\n                    }\n                }\n            ]);\n        }\n\n        this.element.dataset.sortorder = element.sortorder;\n\n        // Enable/disable dragging.\n        const isDraggable = this.element.classList.contains(this.classes.DRAGHANDLE);\n        if (isDraggable && !element.draghandle) {\n            this.element.classList.remove(this.classes.DRAGHANDLE);\n            this.initDragDrop();\n        } else if (!isDraggable && element.draghandle) {\n            this.element.classList.add(this.classes.DRAGHANDLE);\n            this.initDragDrop();\n        }\n    }\n\n    /**\n     * Recursively create a list of all valid destinations for a current category within a parent category.\n     *\n     * @param {Element} item\n     * @param {Number} movingCategoryId\n     * @return {Array<Object>}\n     */\n    createMoveCategoryList(item, movingCategoryId) {\n        const categories = [];\n        if (item.children) {\n            let precedingSibling = null;\n            item.children.forEach(category => {\n                const categoryId = parseInt(category.dataset.categoryid);\n                // Don't create a target for the category that's moving.\n                if (categoryId === movingCategoryId) {\n                    return;\n                }\n                // Create a target to move before this child.\n                let child = {\n                    categoryid: categoryId,\n                    movingcategoryid: movingCategoryId,\n                    precedingsiblingid: precedingSibling?.dataset.categoryid ?? 0,\n                    parent: category.dataset.parent,\n                    categoryname: category.dataset.categoryname,\n                    categories: null,\n                    current: categoryId === movingCategoryId,\n                };\n                const childList = category.querySelector(this.selectors.CATEGORY_LIST);\n                if (childList) {\n                    // If the child has its own children, recursively make a list of those.\n                    child.categories = this.createMoveCategoryList(childList, movingCategoryId);\n                } else {\n                    // Otherwise, create a target to move as a new child of this one.\n                    child.categories = [\n                        {\n                            movingcategoryid: movingCategoryId,\n                            precedingsiblingid: 0,\n                            parent: categoryId,\n                            categoryname: category.dataset.categoryname,\n                            categories: null,\n                            newchild: true,\n                        }\n                    ];\n                }\n                categories.push(child);\n                precedingSibling = category;\n            });\n            if (precedingSibling) {\n                const precedingId = parseInt(precedingSibling.dataset.categoryid);\n                if (precedingId !== movingCategoryId) {\n                    // If this is the last child of its parent, also create a target to move the category after this one.\n                    categories.push({\n                        movingcategoryid: movingCategoryId,\n                        precedingsiblingid: precedingId,\n                        parent: precedingSibling.dataset.parent,\n                        categoryname: precedingSibling.dataset.categoryname,\n                        categories: null,\n                        lastchild: true,\n                    });\n                }\n            }\n        }\n        return categories;\n    }\n\n    /**\n     * Displays a modal containing links to move the category to a new location.\n     *\n     * @param {Event} e Button click event.\n     */\n    async showMoveModal(e) {\n        // Return if it is not menu item.\n        const item = e.target.closest(this.selectors.MOVE_BUTTON);\n        if (!item) {\n            return;\n        }\n        // Return if it is disabled.\n        if (item.getAttribute('aria-disabled') === 'true') {\n            return;\n        }\n\n        // Prevent addition click on the item.\n        item.setAttribute('aria-disabled', true);\n\n        // Build the list of move links.\n        let moveList = {contexts: []};\n        const contexts = document.querySelectorAll(this.selectors.CONTEXT);\n        contexts.forEach(context => {\n            const moveContext = {\n                contextname: context.dataset.contextname,\n                categories: [],\n                hascategories: false,\n            };\n            moveContext.categories = this.createMoveCategoryList(context, parseInt(item.dataset.categoryid));\n            moveContext.hascategories = moveContext.categories.length > 0;\n            moveList.contexts.push(moveContext);\n        });\n\n        const modal = await Modal.create({\n            title: getString('movecategory', 'qbank_managecategories', item.dataset.categoryname),\n            body: Templates.render('qbank_managecategories/move_context_list', moveList),\n            footer: '',\n            show: true,\n            large: true,\n        });\n        // Show modal and add click event for list items.\n        modal.getBody()[0].addEventListener('click', e => {\n            const target = e.target.closest(this.selectors.MODAL_CATEGORY_ITEM);\n            if (!target) {\n                return;\n            }\n            categorymanager.moveCategory(target.dataset.movingcategoryid, target.dataset.parent, target.dataset.precedingsiblingid);\n            modal.destroy();\n        });\n        item.setAttribute('aria-disabled', false);\n    }\n\n    /**\n     * Check and add a child list if needed.\n     *\n     * Check whether the category that has just been added has this category as its parent. If it does,\n     * check that this category has a child list, and if not, add one.\n     *\n     * @param {Object} args\n     * @param {Element} args.element The new category.\n     * @return {Promise<Element>}\n     */\n    async checkChildList({element}) {\n        if (element.parent !== this.getElement().dataset.categoryid) {\n            return null; // Not for me.\n        }\n        let childList = this.getElement(this.selectors.CATEGORY_LIST);\n        if (childList) {\n            return null; // List already exists, it will handle adding the new category.\n        }\n        // Render and add a new child list containing the new category.\n        return this.createChildList({\n            categoryid: element.parent,\n            children: [\n                element.templatecontext,\n            ]\n        });\n    }\n}\n"],"names":["_interopRequireDefault","e","__esModule","default","_templates","_modal","_default","BaseComponent","create","descriptor","this","name","element","id","selectors","CATEGORY_LIST","CATEGORY_ITEM","CATEGORY_CONTENTS","EDIT_BUTTON","MOVE_BUTTON","CONTEXT","MODAL_CATEGORY_ITEM","CONTENT_AREA","CATEGORY_ID","CONTENT_CONTAINER","CHILD_LIST","PREVIOUS_SIBLING","sortorder","classes","NO_BOTTOM_PADDING","DRAGHANDLE","DROPTARGET","ids","CATEGORY","stateReady","initDragDrop","addEventListener","getElement","categorymanager","showEditModal","moveButton","showMoveModal","destroy","deInitDragDrop","classList","contains","getDraggableData","_getDraggableData","dragdrop","DragDrop","undefined","setDraggable","unregister","init","target","document","querySelector","reactive","dataset","categoryid","validateDropData","showDropZone","dropData","closest","add","hideDropZone","remove","drop","event","_precedingSibling","dropTarget","getElementById","targetParentId","parent","parentList","precedingSibling","firstElementChild","previousElementSibling","moveCategory","getWatchers","watch","handler","updatePosition","rerender","checkChildList","_ref","html","js","Templates","renderForPromise","templatecontext","replaceNodeContents","createChildList","context","parentContainer","appendNodeContents","childList","_ref2","newParent","originParent","previousSibling","nextSibling","_previousSibling","parseInt","parentElement","nextElementSibling","insertBefore","appendChild","stateManager","processUpdates","action","fields","childCount","querySelectorAll","length","isDraggable","draghandle","createMoveCategoryList","item","movingCategoryId","categories","children","forEach","category","_precedingSibling2","categoryId","child","movingcategoryid","precedingsiblingid","categoryname","current","newchild","push","precedingId","lastchild","getAttribute","setAttribute","moveList","contexts","moveContext","contextname","hascategories","modal","Modal","title","getString","get_string","body","render","footer","show","large","getBody","_ref3","_exports"],"mappings":"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"}